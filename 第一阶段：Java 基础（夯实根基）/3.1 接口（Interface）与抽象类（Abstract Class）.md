明白，我们来详细梳理 **接口（Interface）与抽象类（Abstract Class）** 在 Java 和 Spring Boot 中的用法，重点是 **Service 接口 + 实现类** 的模式，以及如何支撑接口调用。

---

## 1️ 接口（Interface）

接口是方法的**规范**，只定义方法签名，不包含具体实现。

```java
// 定义 Service 接口
public interface CalculatorService {
    int add(int a, int b);
    int multiply(int a, int b);
}
```

> **特点**：
>
> * 不能有实例化对象（Java 8 后可有默认方法 default）
> * 规定实现类必须实现的行为
> * 支持多实现（一个类可以实现多个接口）

---

## 2️ 实现类（Implementation Class）

实现接口的类提供具体业务逻辑。

```java
// 实现 CalculatorService
@Service
public class CalculatorServiceImpl implements CalculatorService {

    @Override
    public int add(int a, int b) {
        return a + b;
    }

    @Override
    public int multiply(int a, int b) {
        return a * b;
    }
}
```

> **说明**：
>
> * `@Service` 注解让 Spring 管理这个实现类
> * Controller 调用 Service 时可以依赖接口，而不是具体实现类（面向接口编程）

---

## 3️ Controller 调用示例（接口 + 实现类）

```java
@RestController
@RequestMapping("/calc")
public class CalculatorController {

    private final CalculatorService calculatorService;

    // 构造器注入接口
    public CalculatorController(CalculatorService calculatorService) {
        this.calculatorService = calculatorService;
    }

    @GetMapping("/add")
    public int add(@RequestParam int a, @RequestParam int b) {
        // 调用接口方法，实际由实现类执行
        return calculatorService.add(a, b);
    }

    @GetMapping("/multiply")
    public int multiply(@RequestParam int a, @RequestParam int b) {
        return calculatorService.multiply(a, b);
    }
}
```

> **重点理解**：
>
> 1. Controller 依赖 **接口**，而不是具体实现类 → 代码解耦
> 2. Spring 容器自动注入 `CalculatorServiceImpl`（实现类）
> 3. 通过接口调用方法，接口只管“行为规范”，实现类负责具体逻辑

---

## 4️ 抽象类（Abstract Class）

抽象类可以有部分实现逻辑，也可以定义抽象方法供子类实现。

```java
public abstract class AbstractCalculator {

    // 抽象方法
    public abstract int add(int a, int b);

    // 已实现方法
    public int square(int a) {
        return a * a;
    }
}

// 子类实现抽象方法
public class AdvancedCalculator extends AbstractCalculator {

    @Override
    public int add(int a, int b) {
        return a + b;
    }
}
```

> **区别**：
>
> * 接口：方法全是规范（Java 8 默认方法除外）
> * 抽象类：方法可部分实现，可包含属性，子类继承后复用逻辑

---

## 5️ 总结：接口 + 实现类模式在接口开发中的优势

| 优势     | 说明                              |
| ------ | ------------------------------- |
| 面向接口编程 | Controller 依赖接口，不依赖实现类，解耦灵活     |
| 可替换实现  | 不同实现类可切换（例如 Mock 测试、不同策略实现）     |
| 可扩展    | 新增业务逻辑，只需新增实现类，不改接口和 Controller |
| 统一规范   | 接口定义统一方法签名，确保实现类一致性             |

---

### 6️ 案例：Spring Boot Service 接口 + 实现类 + Controller

```
Controller
   |
   v
CalculatorService (接口)
   |
   v
CalculatorServiceImpl (实现类)
```

> 调用流程：
>
> 1. 前端请求 `/calc/add`
> 2. Controller 调用 `CalculatorService.add()`
> 3. Spring 注入 `CalculatorServiceImpl` → 执行 `add` 逻辑
> 4. 返回结果给 Controller → HTTP 响应返回前端

---

如果你愿意，我可以帮你画一张 **Controller → Service 接口 → 实现类 → 方法执行 → 返回前端** 的完整流程图，把接口与实现类的对象关系和调用顺序可视化，一眼看懂整个流程。

你希望我画吗？
