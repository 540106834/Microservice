好，我们把 **“方法的类型”** 这件事一次性理清楚。
不是按语法碎片分，而是按**工程视角 + 使用意图**来分 

你以后看到一个方法，应该能立刻判断：
 **它是哪一类，应该怎么写，怎么用，能不能乱改。**

---

# 一、按「行为职责」分（最重要）

这是你在真实项目里**最该记住的分类**。

---

## 1 查询方法（Query）

 **只读数据，不改状态**

```java
public User getUserById(Long id) {
    return userRepository.findById(id);
}
```

**特征**

* 有返回值
* 不写数据库
* 不发消息
* 不打补丁

**命名**

* `get / find / query / load`

**典型位置**

* Service
* Repository

---

## 2 命令方法（Command）

 **改世界，不关心返回值**

```java
public void createUser(User user) {
    userRepository.save(user);
}
```

**特征**

* 常见 `void`
* 成功 or 抛异常
* 有副作用

**命名**

* `create / update / delete / save`

**典型位置**

* Service
* Controller

---

## 3 判断 / 校验方法（Predicate / Validation）

 **只回答“是 / 否”**

```java
public boolean isValidEmail(String email) {
    return email.contains("@");
}
```

**特征**

* 返回 `boolean`
* 无副作用
* 可重复调用

**命名**

* `is / has / can / should`

---

# 二、按「返回值形态」分（你每天都在用）

---

## 4 无返回值方法（void）

```java
public void logAccess(HttpServletRequest request) {
    ...
}
```

📌 **核心：副作用**

* 打日志
* 写库
* 发消息
* 调接口

---

## 5️⃣ 有返回值方法

```java
public int calculatePrice(int count) {
    return count * 100;
}
```

📌 **核心：计算 / 查询**

---

# 三、按「作用范围」分

---

## 6 实例方法

```java
user.getName();
```

* 依赖对象
* 能访问成员变量

---

## 7 静态方法

```java
Math.max(1, 2);
```

* 不依赖对象
* 更像“工具函数”

口诀 

> **有状态 → 实例
> 没状态 → 静态**

---

# 四、按「是否必须实现」分

---

## 8 普通方法

```java
public void run() { }
```

---

## 9 抽象方法

```java
public abstract void pay();
```

* 只有声明
* 子类必须实现

---

## 10 默认方法（接口）

```java
default void log() {
    System.out.println("log");
}
```

* 接口进化专用
* 不常乱用

---

# 五、按「访问级别」分

```java
public
protected
default（不写）
private
```

 这不是“能不能访问”，而是 **“允不允许被依赖”**。

---

# 六、工程中最常见的组合（非常实用）

| 场景            | 方法类型              |
| ------------- | ----------------- |
| Controller 接口 | public + 命令 / 查询  |
| Service 核心    | public + 命令       |
| Service 内部    | default / private |
| Repository    | 查询方法              |
| 工具类           | static + 查询       |
| 校验器           | boolean 判断        |

---

# 七、一个完整的“方法类型协作示例”

```java
public void placeOrder(CreateOrderRequest request) {

    // 查询
    User user = userService.getUserById(request.getUserId());

    // 判断
    if (!validator.isValidAmount(request.getAmount())) {
        throw new IllegalArgumentException();
    }

    // 命令
    orderService.createOrder(request);
}
```

像一段清晰的叙事：

* 看情况
* 做判断
* 下命令

---

# 最后一句总结 

**方法不是“写法问题”，是“职责声明”。**

你在方法签名里，已经向整个项目宣布了三件事：

1. 我做什么
2. 我改不改世界
3. 我需不需要被依赖

当你能用“方法类型”来审代码时，你已经站在**架构师的视角**了 

如果你愿意，下一步我可以：

* 用你熟悉的 Spring Boot 项目，给你画一张「方法类型分布图」
* 或直接帮你 review 一个方法，看它是不是“混种怪兽”
