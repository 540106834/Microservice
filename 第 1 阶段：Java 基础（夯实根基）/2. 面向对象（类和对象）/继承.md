这个问题问得**非常到位**，已经从“会用继承”进阶到“理解继承的内部结构”了 
我们不绕弯子，**直接把继承这件事拆成零件给你看**。

---

## 一、子类到底“继承了哪些东西”？

一句话总览：

> **子类继承的是：父类的成员，不是父类本身**

具体分 4 类来看 

---

## 1 成员变量（字段）

### 父类

```java
public class BaseService {
    protected String name;
    protected int port;
}
```

### 子类

```java
public class WebService extends BaseService {
}
```

### 实际结果

`WebService` 对象里 **一定有**：

* `name`
* `port`

哪怕你在子类里一行都没写。

 访问规则：

* `public` / `protected`：子类可直接用
* `private`：**存在但不可见**

---

## 2 成员方法（可继承的方法）

```java
public void printInfo() {
    System.out.println("服务：" + name + "，端口：" + port);
}
```

* 子类可以直接调用
* 可以重写（override）
* 不能重写 `final` 方法

 方法是“能力”，子类继承的是能力。

---

## 3 构造方法 ❌（不继承）

这是一个关键点：

> **构造方法不继承，但一定会被调用**

```java
super(name, port);
```

不是“继承构造器”，而是：

 **借用父类构造器完成初始化**

---

## 4 静态成员（特殊规则）

* 静态变量 / 静态方法 **属于类**
* 可以通过子类名访问
* 但**不存在多态**

```java
BaseService.xxx
WebService.xxx   // 只是语法允许
```

---

## 二、那到底“没继承什么”？

| 项目         | 是否继承   |
| ---------- | ------ |
| 构造方法       | ❌      |
| private 成员 | ❌（不可见） |
| 父类实例本身     | ❌      |

子类不是“父类对象”，而是：

> **一个“包含父类部分”的新对象**

---

## 三、`super` 字段到底是干嘛的？

先一句话：

> **`super` 是访问“父类那一层成员”的显式通道**

---

## 场景 1：子类和父类字段同名（最经典）

```java
public class BaseService {
    protected String name = "base";
}

public class WebService extends BaseService {
    protected String name = "web";

    public void print() {
        System.out.println(name);        // web
        System.out.println(super.name);  // base
    }
}
```

### 发生了什么？

* 子类 **隐藏** 了父类字段
* 对象里 **同时存在两份 name**
* `super.name` 明确告诉 JVM：

 “我要的是父类那份”

---

## 场景 2：子类想复用父类逻辑

```java
@Override
public void start() {
    super.start();   // 父类公共逻辑
    System.out.println("启动 Web 服务");
}
```

 这在真实项目里非常常见。

---

## 四、用“对象结构图”理解（非常重要）

当你写：

```java
WebService ws = new WebService("nginx", 80);
```

JVM 内存里的结构更像这样：

```
WebService 对象
├── BaseService 部分
│   ├── name
│   └── port
└── WebService 部分
    └── （自己的字段 / 方法）
```

### `this` 指向：

 整个对象

### `super` 指向：

 其中 **BaseService 那一层**

不是新对象，不是副本。

---

## 五、几个“容易误解但很重要”的点 

### ❗ 字段 ≠ 方法

* 字段：**编译期绑定**
* 方法：**运行期多态**

```java
BaseService s = new WebService();
System.out.println(s.name);   // 父类字段
s.start();                    // 子类方法
```

这点很多人第一次都会懵 

---

## 六、回到你的 Service 案例（一句话收尾）

> **继承的是：属性 + 行为规范
> super 的作用：明确使用父类那一层实现**

你现在这套理解，已经完全够你：

* 读 Spring 源码
* 理解 Controller / Service / Repository
* 写干净的继承体系

---

## 七、下一步进阶建议 

如果你愿意继续，我可以帮你：

1️⃣ 用继承 + 模板方法模式重构 Service
2️⃣ 对比 **继承 vs 接口** 的真实使用边界
3️⃣ 用一个“运维服务编排器”把多态用到极致
