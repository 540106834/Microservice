# **Java 虚拟机（JVM）中堆（Heap）和栈（Stack）的区别与关系**

---

## 1️⃣ JVM 内存概览

JVM 内存主要分几块，其中最常接触的是：

| 区域                 | 描述                     |
| ------------------ | ---------------------- |
| **方法区（Metaspace）** | 存储类信息、静态变量、常量池         |
| **堆（Heap）**        | 存储对象实例，是垃圾回收的主要区域      |
| **栈（Stack）**       | 每个线程私有，存储方法调用、局部变量和操作栈 |
| 本地方法栈 / PC 寄存器     | JNI、本地方法调用辅助区域         |

今天重点讲 **堆和栈**。

---

## 2️⃣ 栈（Stack）

**特点**：

1. **线程私有**，每个线程都有独立栈
2. **存储内容**：

   * 方法调用信息（栈帧）
   * 局部变量（基本类型、对象引用）
   * 方法执行的操作数
3. **先进后出（LIFO）**
4. **分配速度快**，由 JVM 自动管理
5. **生命周期**：随着方法调用和返回自动销毁

**示例**：

```java
public class StackExample {
    public void methodA() {
        int x = 10;   // 局部变量，存栈
        methodB();
    }

    public void methodB() {
        int y = 20;   // 局部变量，存栈
    }

    public static void main(String[] args) {
        StackExample example = new StackExample(); // 对象在堆
        example.methodA();
    }
}
```

* `x` 和 `y` 在栈中
* 方法返回后，栈帧销毁

---

## 3️⃣ 堆（Heap）

**特点**：

1. **所有线程共享**
2. **存储内容**：

   * 对象实例（new 创建的对象）
   * 数组
3. **垃圾回收（GC）管理）**
4. **生命周期**：由 GC 决定对象何时销毁

**示例**：

```java
public class HeapExample {
    public static void main(String[] args) {
        Person p = new Person("Alice"); // 对象在堆中
        p.age = 25;                     // 修改堆中对象属性
    }
}

class Person {
    String name;
    int age;

    Person(String name) {
        this.name = name;
    }
}
```

* `p` 是引用变量，存栈
* `new Person(...)` 的对象存堆
* 对象由 GC 回收

---

## 4️⃣ 栈 vs 堆 对比

| 特性      | 栈（Stack）       | 堆（Heap）    |
| ------- | -------------- | ---------- |
| 所有权     | 线程私有           | 多线程共享      |
| 存储内容    | 局部变量、方法调用栈帧    | 对象实例、数组    |
| 分配/释放速度 | 快（CPU 指针移动）    | 慢（GC 回收）   |
| 生命周期    | 随方法调用和返回自动销毁   | 由 GC 管理    |
| 大小      | 相对较小，固定        | 较大，可动态扩展   |
| 访问方式    | LIFO（先进后出）     | 无序，需要引用访问  |
| 典型用途    | 基本类型、引用变量、方法参数 | 对象存储、实例化数据 |

---

## 5️⃣ 栈和堆的关系示例

```java
public class Demo {
    public static void main(String[] args) {
        int a = 10;          // 栈
        Person p = new Person("Bob"); // 栈里存 p 引用，堆里存对象
        changePerson(p);
    }

    static void changePerson(Person person) {
        person.name = "Alice"; // 修改堆对象
        person = new Person("Charlie"); // 栈局部引用，堆对象新创建
    }
}

class Person {
    String name;
    Person(String name) { this.name = name; }
}
```

✅ 说明：

* 方法传递的是对象 **引用**
* 栈里保存引用，堆里保存对象
* 栈上的引用改变不会影响调用方法里的引用，但堆对象可以被修改

---

💡 **实战经验**：

1. **基本类型和引用变量**放在栈
2. **对象实例和数组**放在堆
3. **栈小且快速**，适合短生命周期数据
4. **堆大且共享**，适合对象存储，但需注意 GC 开销

---

我可以帮你画一张 **JVM 堆与栈示意图**，标注对象引用、方法调用栈帧和 GC 对象生命周期，看一眼就懂栈堆关系。

你希望我画吗？
