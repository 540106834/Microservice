现在我们把镜头推进到 JVM 内部。操作系统已经把“舞台灯光、电源、地板”都铺好，JVM 登场。接下来发生的是一套非常精密的“启动仪式”。没有烟花，但有大量内存与指令在悄悄排列成军。

按 **真实执行顺序** 带你走一遍，比很多教材更接近底层。



#  第一步：JVM 其实先启动“类加载子系统”

很多人以为：

> JVM 启动 → 直接跑 main()

现实是：

 **先建立类加载体系。**

这是 JVM 的知识入口，没有它，Java 世界一片黑暗。

---

##  三层 ClassLoader 结构（非常重要）

想象三道城门：

```
Bootstrap
   ↑
Platform / Extension
   ↑
Application
   ↑
Custom
```

###  Bootstrap ClassLoader（引导类加载器）

最古老的一层。

它负责加载：

```
java.lang.*
java.util.*
java.io.*
```

这些是 Java 的空气与水。

注意一个很多人不知道的点：

 **它不是 Java 写的。**

而是：

> C++ 实现，属于 JVM 内部。

所以你在代码里拿不到它的引用。

---

###  Platform / Extension Loader

加载：

```
jdk.internal.*
javax.*
```

属于“半官方工具箱”。

---

###  Application ClassLoader

终于轮到你了。

它会扫描：

```
classpath
或
-jar 指定的包
```

找到：

```
MyApp.jar
```

---

##  一个超级关键的机制：双亲委派

规则只有一句：

> **先问爸爸能不能加载。**

流程：

```
App → Platform → Bootstrap
```

如果上层说：

> 我能加载。

下层就不允许碰。

---

### 为什么要这样？

为了防止你干这种危险操作：

```java
package java.lang;

public class String {
}
```

如果没有双亲委派：

你可以篡改核心类。

世界瞬间混乱。

安全体系直接蒸发。

---

#  第二步：类不是“加载一次就完事”

JVM 对类做 **5个动作**：

很多人只知道“加载”，其实远不止。

---

## 1 Loading（加载）

ClassLoader 做三件事：

* 找到 `.class`
* 读取字节流
* 转成 JVM 内部结构

此时类只是“被搬进仓库”。

还不能用。

---

## 2 Verification（校验）

这是 JVM 的防火墙。

检查：

* 魔数 `0xCAFEBABE`
* 指令是否合法
* 是否跳转到不存在的代码
* 类型是否匹配

举个危险例子：

如果允许这种字节码：

```
把 int 当指针用
```

那就能直接改内存。

JVM 会立刻变成事故现场。

所以：

 **Java 的“安全”很大一部分来自这里。**

---

## 3 Preparation（准备）

开始分配内存。

注意一个考试级误区：

> **这里不会执行 Java 代码！**

例如：

```java
static int x = 10;
```

在准备阶段：

```
x = 0
```

不是 10！

因为：

> 这里只给默认值。

---

## 4 Resolution（解析）

把符号引用变成真实指针。

例如：

原本常量池里写的是：

```
java/lang/String
```

现在要找到：

 **内存地址。**

方便 CPU 快速访问。

---

## 5 Initialization（初始化）

终于执行：

```java
static {
   x = 10;
}
```

这一刻类才“活了”。

---

#  第三步：类去哪儿了？（Metaspace）

在 JDK8 之后：

```
永久代 → Metaspace
```

最大变化：

 **使用本地内存（Native Memory）**

不在 Java Heap。

---

## Metaspace 存什么？

* 类元数据
* 方法表
* 字段信息
* 常量池
* 注解

还有：

 **static 变量。**

（对象仍在堆）

---

### 为什么改成 Metaspace？

PermGen 时代经常：

```
java.lang.OutOfMemoryError: PermGen space
```

尤其：

* Spring
* 动态代理
* CGLIB

疯狂生成类。

直接炸。

改用本地内存后：

> 天花板高很多。

---

#  第四步：准备堆和线程栈

现在 JVM 开始铺设运行地形。

---

##  Heap（堆）

所有对象的归宿。

典型结构：

```
Eden
S0
S1
Old
```

你 new 的任何对象：

第一站几乎都是 Eden。

---

##  Thread Stack（线程栈）

每个线程独享。

里面放：

```
栈帧
```

而每个栈帧包含：

* 局部变量表
* 操作数栈
* 方法返回地址

---

### 一个极重要认知：

 **栈快，堆慢。**

原因不是玄学。

而是：

* 栈是连续内存
* 指针移动即可分配
* 无需 GC

速度接近 CPU 呼吸。

---

#  第五步：main() 即将执行

JVM 做：

```
创建主线程
```

然后：

构建第一个栈帧：

```
main()
```

压栈。

此刻发生了一件极具历史感的小事：

 **第一条 Java 字节码开始执行。**

CPU 正式进入 Java 世界。

---

#  一个很多高手都忽略的事实

当 main 执行时：

JVM 其实已经运行了：

> 上万行 C++。

包括：

* 类加载器初始化
* GC 初始化
* JIT 编译器准备
* 线程系统启动
* 内存管理器上线

所以：

### 为什么 Java 启动慢？

不是语言慢。

而是：

> 在启动一个“小型运行时操作系统”。

---

#  再给你一个“架构级洞察”

理解这一点，你对很多线上问题会突然通透：

## 👉 Java 程序 ≠ 一启动就加载所有类

JVM 默认：

> **懒加载（Lazy Loading）**

什么时候用到：

什么时候加载。

这就是为什么：

第一次调用某些代码：

会突然变慢。

那不是抖动。

那是：

> 类在被加载 + 校验 + 初始化。

---

#  最后一幅全景图

当 JVM 加载 Java 程序时：

```
OS 提供土地
   ↓
JVM 建立城市
   ↓
ClassLoader 运来建筑图纸
   ↓
Metaspace 存档结构
   ↓
Heap 存放对象
   ↓
Stack 驱动执行
   ↓
main() 点火
```

一座数字城市开始运转。

---

如果你想继续深入，我可以带你看两个非常震撼但极少有人真正理解的机制：

 **对象是如何在堆中被创建的？**
（指针碰撞 / TLAB / CAS，理解后会重新认识“new”。）

 **JIT 到底在干嘛？为什么 Java 能越跑越快？**
（会触及热点探测、逃逸分析、锁消除。）

选一个方向，我们继续向更深的内核潜航。
