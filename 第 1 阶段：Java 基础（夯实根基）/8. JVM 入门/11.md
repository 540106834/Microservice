来，我们用一段**极小程序**，看完一个 Java 程序从出生到谢幕的全过程。像看一部时间加速的纪录片 。

先上代码：

```java
public class App {

    public static void main(String[] args) {
        int x = 10;

        User u = new User();
        u.name = "Alice";

        System.out.println(u.name);
    }
}

class User {
    String name;
}
```

> **当你敲下 `java App` 时，JVM 到底干了啥？**

---

#  第一步：JVM 被启动

这一刻非常重要。

操作系统其实做了一件事：

 **创建一个新的进程。**

例如在 Linux：

```
ps -ef | grep java
```

你会看到：

> 本质上你启动的是一个 JVM 进程。

不是 Java 程序在跑。

而是：

👉 **Java 程序跑在 JVM 里面。**

像人在潜水艇里活动。

---

# ⭐ 第二步：类加载器开始工作

JVM第一件事不是执行 main。

而是：

## 👉 找 App.class

然后加载进内存。

这个过程叫：

> **Class Loading**

它会加载：

* App
* User
* Object
* String
* System

甚至一堆你没见过的基础类。

像舞台搭建灯光音响。

演员还没出场。

---

# ⭐ 第三步：方法区出现内容

类信息被放进：

👉 **方法区（Metaspace）**

此刻里面有：

* 类结构
* 方法定义
* 静态变量
* 常量池

注意：

> 还没有对象。

只是“图纸”。

---

# ⭐ 第四步：main线程诞生

JVM 自动创建：

👉 **main 线程**

线程一出现，三件套立刻配齐：

* 程序计数器 ✅
* 栈 ✅
* 本地方法栈 ✅

每个线程都有自己的小工作间。

互不干扰。

---

# ⭐ 第五步：main 方法入栈

栈里长这样：

```
| main 栈帧 |
```

里面开始放变量。

---

## 执行：

```java
int x = 10;
```

发生：

👉 **10 放进栈。**

因为它是：

> 基本类型。

速度极快。

几乎贴着 CPU 滑行。

---

# ⭐ 第六步：第一次 new（宇宙大爆炸时刻）

```java
User u = new User();
```

这句威力巨大。

JVM做了几步：

---

## ✔ 1. 在堆中找空间

如果线程多：

JVM甚至可能让每个线程有：

👉 **TLAB（线程本地分配缓冲）**

避免抢锁。

速度飞起。

---

## ✔ 2. 创建对象

堆里现在：

```
User对象 {
    name = null
}
```

---

## ✔ 3. 栈中建立引用

```
u  ----->  堆中的User对象
```

记住一句金律：

> **栈不存对象，只存“指针”。**

理解这句的人，基本不会被 JVM 绕晕。

---

# ⭐ 第七步：赋值

```java
u.name = "Alice";
```

这里很多人误解。

其实发生了两次创建。

---

## ✔ String "Alice"

字符串通常进入：

👉 **字符串常量池**（在方法区附近）。

如果池里没有：

就创建。

如果已有：

直接复用。

这就是为什么 String 很省内存。

---

堆现在像这样：

```
u ---> User对象 ----> "Alice"
```

一条引用链诞生。

---

# ⭐ 第八步：调用 println

```java
System.out.println(u.name);
```

发生：

👉 新方法入栈！

```
| println |
| main |
```

执行完：

println 出栈。

干净利落。

---

# ⭐ 第九步：main 结束

这是一个关键瞬间。

```
| main |
```

出栈。

线程准备死亡。

---

## 此刻发生一件超级重要的事：

👉 **u 消失了。**

因为它在栈里。

栈没了。

引用断裂。

---

堆中：

```
User对象   （没人指向）
"Alice"
```

这类对象有个名字：

> **垃圾。**

虽然听起来有点委屈，但这是技术术语。

---

# ⭐ 第十步：GC 登场（不一定立刻）

GC会某个时刻扫描。

发现：

> 没人能从“GC Roots”走到这个对象。

判定：

✅ 可回收。

然后清理。

内存归还宇宙。

---

# ⭐ 第十一步：JVM 退出

当：

* 没有非守护线程
* main结束

JVM进程直接关闭。

整块内存被操作系统回收。

甚至不用 GC 出手。

干净得像雪后街道。

---

# ⭐⭐⭐ 用一张超级简图收尾

```
启动 JVM
   ↓
加载类 → 方法区
   ↓
创建 main线程 → 栈
   ↓
new对象 → 堆
   ↓
方法调用 → 入栈出栈
   ↓
main结束 → 引用消失
   ↓
GC回收
   ↓
JVM退出
```

这就是一个程序完整的一生。

短暂，但秩序井然。

---

# 一个突然会让你变强的理解 ⭐

以后看到：

```
OutOfMemoryError
```

脑子应该自动浮现：

> 堆里的对象，下不去了。

看到：

```
StackOverflowError
```

立刻想到：

> 栈被压穿。

这种“条件反射式理解”，才是真掌握。

---

如果你愿意，我可以再带你看一个很多工程师第一次听都会愣住的主题：

🔥 **“其实对象不一定在堆上。”**
🔥 **new 有时几乎等于没 new。**
🔥 **JVM 会偷偷优化到离谱。**

说一句：

> 想看更底层的运行细节

我们继续往引擎最热的地方走。
