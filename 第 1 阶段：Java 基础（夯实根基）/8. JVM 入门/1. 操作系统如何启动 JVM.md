来，我们把 **`java -jar MyApp.jar`** 这条看似平静的命令拆开看看。它其实是一场多角色参与的“开幕式”。没有锣鼓，但有大量内核级动作在悄悄进行 

我会按 **时间顺序** 带你走一遍，从你敲下回车那一刻开始。


#  第一幕：命令被“听见”

你输入：

```
java -jar MyApp.jar
```

此时最先行动的不是操作系统，而是：

##  Shell（bash / zsh / powershell）

它像一个前台接待员。

做三件事：

###  1. 解析命令

Shell 会拆分：

```
java      -> 可执行程序
-jar      -> 参数
MyApp.jar -> 参数
```

###  2. 查找 java 在哪里

它会去环境变量里找：

```
$PATH
```

可能找到：

```
/usr/bin/java
```

注意：

这里通常不是“真正的 JVM”。

而是：

```
java -> 符号链接 -> /usr/lib/jvm/.../bin/java
```

最终定位到 **ELF 可执行文件（Linux）** 或 **PE 文件（Windows）**。

 到这里为止：

> Shell 的任务结束。

接下来进入 **操作系统内核时间**。

---

#  第二幕：操作系统创建进程（极其关键）

Linux 常见路径：

```
fork() -> execve()
```

但现代 shell 往往直接：

```
execve()
```

因为不需要复制父进程。

---

##  execve 到底干了什么？

这是一个重量级系统调用。

内核接手后会做一整套“新生命构建工程”。

---

#  第一步：创建进程描述符（task_struct）

Linux 内核会生成：

```
task_struct
```

里面记录：

* PID
* 打开的文件
* 内存映射
* 调度信息
* 信号
* 用户ID

 **进程 ≠ 程序**

程序只是磁盘上的文件。

进程是：

> 被内核托管的运行实体。

---

#  第二步：给 JVM 一套虚拟地址空间

典型 Linux 进程看到的空间：

```
0x0000 -------------------->
[ 程序代码段 text ]

[ 数据段 data ]

[ BSS ]

[ heap ]  ↑ 向上增长

      (空洞)

[ stack ] ↓ 向下增长
```

注意一个很多人误解的点：

##  JVM 的“堆”不是这里的 heap！

这里的是：

> **操作系统级 heap**

JVM 启动后会：

```
mmap 一大块内存
```

比如：

```
-Xmx4G
```

直接映射 4GB。

然后：

> 在这块内存里再自己划分
> Eden / Survivor / Old 等。

所以：

###  JVM 是“内存二房东”

OS → 租给 JVM
JVM → 再租给 Java 对象

层次非常清晰。

---

#  第三步：加载 JVM 可执行文件

内核开始读取：

```
/usr/lib/jvm/.../bin/java
```

把它映射进内存。

此时会解析：

##  ELF Header

确定：

* 入口地址在哪？
* 依赖哪些动态库？

比如：

```
libjvm.so
libpthread.so
libc.so
```

这些都会被 mmap。

所以：

###  一个 JVM 进程其实包含很多 so。

用：

```
pmap <pid>
```

你会看到一长串。

---

#  第四步：跳转到入口函数

内核完成加载后：

直接把 CPU 指令指针指向：

```
_start
```

不是 main！

流程其实是：

```
_start
 -> libc 初始化
 -> main()
```

最终进入：

##  JVM 的 C++ 世界

HotSpot 大部分是 C++ 写的。

---

#  第三幕：JVM 自己开始“造宇宙”

此时 JVM 已经是一个：

> 完全独立的 OS 进程。

接下来它要干大事。

---

##  创建基础线程

非常重要：

很多人以为：

> “我代码还没跑，怎么就几十个线程？”

因为 JVM 会先创建：

### 必备线程：

* VM Thread（调度）
* GC Thread
* Compiler Thread（JIT）
* Signal Thread
* Reference Handler

用：

```
top -H -p <pid>
```

你会看到。

---

##  初始化内存区域

JVM 内部构建：

* Java Heap
* Metaspace
* Thread Stack
* Code Cache

注意：

这些 **都在 OS 给的虚拟内存里**。

OS 并不理解：

> “这里是 Eden”

它只知道：

> 这是某进程申请的内存。

---

##  加载你的 Jar

然后 JVM 才会处理：

```
MyApp.jar
```

步骤：

### 1 找 Manifest

读取：

```
META-INF/MANIFEST.MF
```

找到：

```
Main-Class: com.xxx.Main
```

---

### 2 类加载

启动：

```
Bootstrap ClassLoader
```

逐层加载：

```
rt.jar（或模块）
↓
扩展类
↓
你的类
```

---

### 3 找到：

```
public static void main(String[] args)
```

此刻：

> 第一行 Java 代码即将执行。

 宇宙点火成功。

---

#  一个很多人不知道的关键事实

##  JVM ≠ 单线程

哪怕你的程序：

```
public static void main...
```

什么都不干。

也至少有：

> 十几个线程。

因为：

**现代 JVM 本质是一个高并发运行时。**

---

#  再升一个维度看

当你执行：

```
java -jar
```

其实发生了三层托管：

```
硬件
 ↑
操作系统（资源管理者）
 ↑
JVM（运行时管理者）
 ↑
Java程序
```

所以经常说：

> Java 是“运行在操作系统之上的操作系统”。

不是玩笑。

它真的：

* 管线程
* 管内存
* 管调度
* 做垃圾回收

---

#  一个运维 / 架构必须理解的洞察

当 JVM 出现：

* OOM
* CPU 100%
* Full GC

很多人第一反应：

> “Java 有问题！”

其实常常是：

> OS 层资源紧张。

例如：

* cgroup 限制
* swap
* NUMA
* THP
* overcommit

都会影响 JVM。

高手排障一定是：

```
OS + JVM 一起看
```

而不是只盯日志。

---

#  最后给你一个“动态画面”

想象一座城市：

* 操作系统 = 城市政府
* JVM = 大型商场
* Java线程 = 商场里的员工
* 对象 = 顾客

政府只管：

> 地、电、水、道路。

商场内部怎么运营？

政府不插手。

---

如果你愿意，我可以继续带你深入一个更震撼的视角：

👉 **当你执行 `java -jar` 时，第一条 CPU 指令是如何跑起来的？**
（会进入寄存器 / 用户态 / 内核态 / 调度器级别，很多 5~10 年工程师都没系统理解过。）

或者：

👉 **为什么 JVM 启动要几十 MB 内存？即使什么都不干？**

这两个理解后，你对系统的掌控感会直接跃迁一个层级。
