很好，这一步已经进入 **“可上线系统级数据库设计”** 的范畴了。
我们不再做练习模型，而是做一套：

✅ 能抗设备洪峰
✅ 可追溯
✅ 可扩展多学校
✅ 支持排障
✅ 接近真实生产

但仍保持 **最小必要复杂度**，避免架构过度。

准备好，开始搭这座数据城池。

---

# ⭐ 一、整体设计思想（先统一大脑模型）

核心分三层：

```
基础主数据层（谁是谁）
        ↓
Raw原始数据层（设备说了什么）
        ↓
业务结果层（系统认定发生了什么）
```

千万记住：

> **Raw ≠ Attendance**

一个是“证据”，一个是“判决”。

---

# ⭐ 二、推荐最终表结构（企业感明显版）

我按真实系统依赖顺序排。

---

# ✅ 1️ school（学校根表）

```sql
CREATE TABLE school (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    school_name VARCHAR(100) NOT NULL,
    status TINYINT DEFAULT 1,
    created_at DATETIME
);
```

所有业务表必须能追溯到它。

它是数据宇宙的恒星。

---

# ✅ 2️ class（班级）

```sql
CREATE TABLE class (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    school_id BIGINT NOT NULL,
    class_name VARCHAR(50),
    grade VARCHAR(20),
    created_at DATETIME,
    INDEX idx_school (school_id)
);
```

避免把班级写死在 student。

未来调班会救你一命。

---

# ✅ 3️ student（学生）

```sql
CREATE TABLE student (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    school_id BIGINT NOT NULL,
    class_id BIGINT,
    student_name VARCHAR(50),
    status TINYINT DEFAULT 1,
    created_at DATETIME,

    INDEX idx_school (school_id),
    INDEX idx_class (class_id)
);
```

### ⭐ 小高手技巧：

即使能通过 class 推导 school，
**仍然保留 school_id。**

这是典型：

> 用空间换性能。

---

# ✅ 4️ card（学生卡）

卡一定要独立。

现实世界中：

* 丢卡
* 补卡
* 换卡

天天发生。

```sql
CREATE TABLE card (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    school_id BIGINT NOT NULL,
    student_id BIGINT NOT NULL,
    card_no VARCHAR(30) UNIQUE,
    status TINYINT,
    issued_at DATETIME,

    INDEX idx_student(student_id)
);
```

---

# ✅ 5️ device（考勤设备）

```sql
CREATE TABLE device (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    school_id BIGINT NOT NULL,
    device_sn VARCHAR(50) UNIQUE,
    location VARCHAR(100),
    status TINYINT,
    last_heartbeat DATETIME,

    INDEX idx_school(school_id)
);
```

未来可扩展：

* 在线状态
* 固件版本
* 信号强度

---

#  6️ attendance_raw（极关键）

这是系统的“黑匣子”。

### 永远先写 Raw。

```sql
CREATE TABLE attendance_raw (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,

    school_id BIGINT,
    device_sn VARCHAR(50),

    func_code VARCHAR(4),
    sn VARCHAR(10),

    raw_payload TEXT NOT NULL,   -- 原始报文（建议HEX）

    received_at DATETIME,

    parse_status TINYINT DEFAULT 0,
    -- 0 未解析
    -- 1 成功
    -- 2 失败

    error_msg VARCHAR(255),

    INDEX idx_device_time(device_sn, received_at),
    INDEX idx_parse(parse_status)
);
```

---

##  为什么不强依赖 student？

因为：

> Raw 是“设备视角”，不是“业务视角”。

设备可能发：

* 未注册卡
* 非本校卡
* 错卡

都必须记录。

---

#  7️ attendance（最终业务表）

这是给业务查的。

不是给机器查的。

```sql
CREATE TABLE attendance (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,

    school_id BIGINT NOT NULL,
    student_id BIGINT NOT NULL,
    card_id BIGINT,
    device_id BIGINT,

    attendance_time DATETIME NOT NULL,
    direction TINYINT,  -- 0进校 1离校

    raw_id BIGINT,   -- 追溯Raw

    created_at DATETIME,

    INDEX idx_student_time(student_id, attendance_time),
    INDEX idx_school_time(school_id, attendance_time)
);
```

---

##  raw_id 是一个非常有味道的字段

它让链路变成：

```
Attendance → Raw → 原始报文
```

排障速度直接起飞。

很多系统没有这个字段。

出事故时：

工程师眼神逐渐失焦。

---

# ⭐ 三、推荐数据流（非常标准）

```
设备
 ↓
Netty网关
 ↓
attendance_raw   ⭐先存
 ↓
解析服务
 ↓
attendance
```

顺序不要反。

这是工业共识。

---

# ⭐ 四、一个 90% 人忽略的优化建议

## 👉 Raw 表可以不放 school_id（可选）

为什么？

因为写入路径应该：

> **越短越好。**

极致高并发场景甚至只存：

```
device_sn
raw_payload
time
```

解析时再补 school_id。

这是：

> 写优化思想。

但如果你现在是普通并发：

👉 **建议保留 school_id。**

查询更爽。

---

# ⭐ 五、未来扩展能力（这套结构已经支持）

✔ 多学校
✔ 亿级考勤
✔ 审计追溯
✔ 数据补偿
✔ Kafka异步解析
✔ 分库分表

已经超过很多中型公司。

不是玩具模型。

---

# 🌟 给你一句架构判断金句：

> **凡是“不可重新生成”的数据，都要Raw。**

考勤就是。

丢一条，历史就被改写。

---

如果你愿意，我还能继续带你升维一层：

🔥 **是否要加“去重表”？（设备重发很常见）**
🔥 **Attendance 要不要按月分表？**
🔥 **网关到底该不该直连 MySQL？**
🔥 **10万设备同时上线怎么顶？**

直接说：

👉 **升级到高并发版设计**

我可以给你一套接近智慧校园生产架构的数据库模型。
