很好。现在我们走到一个**技术世界的重力层**。

如果系统是一栋楼：

* 第一阶段 = 知道要建什么楼
* 第二阶段 = 画结构图
* **第三阶段 = 往地下灌混凝土**

而现实是：

> **90% 的系统，不是被代码拖垮的。
> 而是死于数据库设计。**

代码还能重写。

表一旦上线……

改一次，像给高速列车换轨道。

---

#  第三阶段的真正目标

不是“会建表”。

而是达到这个认知：

> **表结构 = 业务规则的物理化。**

你的数据库，其实在替你执行纪律。

设计错，系统天天违规。

---

#  第一刀：区分两种“完全不同”的表

这是超关键认知。

## ✅ 状态表（State Table）

描述：

> “现在是什么情况？”

例如：

### student

| id | name | status |
| -- | ---- | ------ |
| 1  | 小明   | NORMAL |

特点：

* 会 update
* 数据量不爆炸
* 只关心当前

像一张实时户口本。

---

## ✅ 事实表（Event Table）

描述：

> “世界发生过什么？”

例如：

### attendance

| id | student_id | check_time |
| -- | ---------- | ---------- |
| 1  | 1          | 07:59      |

特点：

* **几乎不 update**
* **绝不 delete**
* 疯狂增长

它是系统的“历史记忆”。

删它？

等于失忆。

---

#  新手最常犯的灾难

把 attendance 写成这样：

```
student_id
date
status   (late / leave / normal)
```

看起来很省事。

其实埋了一颗慢性炸弹。

为什么？

因为现实世界不是“状态”，而是：

> **一连串事件。**

可能出现：

* 07:50 到校
* 09:10 又外出
* 10:30 返回

你一个 status 怎么表达？

表达不了。

于是开始疯狂加字段……

系统逐渐怪异。

---

# ⭐ 正确姿势：让表尊重现实

建议结构：

## attendance（事件表）

```
id
student_id
check_time
type   (IN / OUT)
source (DEVICE / MANUAL)
```

注意这个 **source**。

未来审计时，你会感谢今天的自己。

老师改过记录？
设备异常？

一查便知。

这叫：

> **可追溯性。**

成熟系统的灵魂。

---

#  第二刀：永远用 ID，不用“名字关联”

我见过太多这样的表：

```
class_name = "三年二班"
```

半年后班级改名：

💥 全库错乱。

记住一句工程铁律：

> **名字是皮肤，会变。
> ID 是骨头。**

所以：

```
class_id ✔
```

不要偷懒。

未来那次救火，会少掉很多白发。

---

# ⭐ 第三刀：时间字段，是隐形核弹

很多人随手：

```
create_time
```

结束。

但考勤系统对时间极度敏感。

建议直接形成习惯：

```
check_time   DATETIME(3)
```

为什么 `(3)`？

毫秒级。

当两个学生在同一秒刷卡时：

没有毫秒，你可能分不清顺序。

以后排查并发问题会抓狂。

---

# 🚨 一个90%新人会踩的坑

### 用 DATE 存考勤 ❌

```
2026-02-01
```

那我问你：

迟到怎么判断？

不知道几点到的。

系统瞬间失明。

---

# ⭐ 第四刀：索引 = 数据库的导航系统

没有索引的查询，就像在沙漠找一粒米。

考勤表必备：

## 高频查询：

👉 查某学生最近记录：

```
index(student_id, check_time)
```

顺序很重要！

不是装饰。

是查询路径。

---

# 🧭 第五刀：哪些表“绝不能删”？

记住一个判断：

> **只要涉及责任追踪，就不能删。**

例如：

* attendance ✔
* leave ✔
* 操作日志 ✔

正确做法：

```
is_deleted = 1
```

逻辑删除。

现实世界发生过的事，系统必须记住。

否则某天家长投诉：

> “我孩子明明到校了！”

你却查不到。

那不是bug。

那是事故。

---

# ⭐ 高阶提示（很多人3年后才懂）

### 不要搞“万能状态字段”

新手特别爱：

```
status
```

装一切：

* late
* leave
* pending
* abnormal

结果是：

> 一个字段承受了不该承受的复杂度。

更好的方式：

👉 不同业务，用不同表表达。

数据库不是省字段比赛。

而是：

> **表达清晰度比赛。**

---

# 🔥 给你一个真实翻车现场

某学校系统这样设计：

```
attendance:
status = leave
```

后来上线审批流。

问题来了：

👉 请假未审批时算什么？

他们新增：

```
pending_leave
```

再后来：

老师可以驳回。

又加：

```
rejected_leave
```

半年后，这个字段像一棵圣诞树 🎄。

没人敢改。

---

# ✅ 第三阶段完成标志（非常硬核）

如果你开始形成这种直觉：

✔ 事实用事件表
✔ 当前用状态表
✔ ID > 名称
✔ 时间要精准
✔ 审计数据不删

我要认真告诉你：

> 你已经超过大量“只会JPA自动建表”的工程师。

真的存在很多。

---

# 🔥 想不想做一道“架构嗅觉测试”？（超有价值）

现在来了一个需求：

> **学生一天只允许打卡一次。**

你第一反应会：

A️⃣ 用代码判断
B️⃣ 在数据库加唯一索引

别急答。

这题专门测：

> 👉 你是“写程序的人”，
> 还是开始成为“设计规则的人”。

说出你的选择，我们把你的数据库功底再压实一层。
