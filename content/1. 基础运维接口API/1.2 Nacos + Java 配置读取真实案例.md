好，来一个**真正能跑、也符合你做接口/运维方向的 Nacos + Java 配置读取真实案例**。
不画饼，不只讲概念，直接落到代码和配置 

---

## 一、真实业务场景

**场景**

* Spring Boot 接口服务
* 配置放在 Nacos
* 动态控制：

  * 数据库地址
  * 功能开关
  * 超时时间
* **不重启服务即可生效**

---

## 二、Nacos 中的配置（核心）

### 1️ Nacos 配置中心新建配置

**Data ID**

```
demo-api.yaml
```

**Group**

```
DEFAULT_GROUP
```

**内容**

```yaml
server:
  port: 8081

app:
  name: demo-api
  feature:
    enableLogin: true
  timeout: 3000

db:
  host: 127.0.0.1
  port: 3306
  name: demo
```

这是真实公司里常见的配置结构，不是玩具级。

---

## 三、Spring Boot 项目结构

```
demo-api
├── src/main/java
│   └── com.example.demo
│       ├── DemoApplication.java
│       ├── controller
│       │   └── TestController.java
│       └── config
│           └── AppConfig.java
└── src/main/resources
    └── bootstrap.yml
```

⚠️ **重点：用 `bootstrap.yml`，不是 application.yml**

---

## 四、bootstrap.yml（连接 Nacos）

```yaml
spring:
  application:
    name: demo-api

  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848
        file-extension: yaml
        group: DEFAULT_GROUP
        namespace: public
```

说明一句话就够了：

> Spring Boot 启动时，先从 Nacos 拉配置，再启动容器

---

## 五、Java 代码读取配置（重点）

### 方式一：`@ConfigurationProperties`（最推荐）

#### 1️ 配置类

```java
package com.example.demo.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "app")
@RefreshScope
public class AppConfig {

    private String name;
    private Feature feature;
    private int timeout;

    public static class Feature {
        private boolean enableLogin;

        public boolean isEnableLogin() {
            return enableLogin;
        }

        public void setEnableLogin(boolean enableLogin) {
            this.enableLogin = enableLogin;
        }
    }

    // getter / setter
}
```

✅ 特点

* **结构清晰**
* **支持动态刷新**
* **适合复杂配置**

---

#### 2️ Controller 使用配置

```java
package com.example.demo.controller;

import com.example.demo.config.AppConfig;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {

    private final AppConfig appConfig;

    public TestController(AppConfig appConfig) {
        this.appConfig = appConfig;
    }

    @GetMapping("/config")
    public Object getConfig() {
        return appConfig;
    }

    @GetMapping("/login")
    public String login() {
        if (!appConfig.getFeature().isEnableLogin()) {
            return "login disabled";
        }
        return "login ok";
    }
}
```

---

## 六、动态刷新验证（非常关键）

### 修改 Nacos 配置

```yaml
app:
  feature:
    enableLogin: false
```

**不重启服务**

再次访问：

```
GET /login
```

返回：

```
login disabled
```

 这就是 Nacos 的核心价值
配置像旋钮，系统像音响，转一下立刻生效。

---

## 七、另一种常见方式（简单配置）

```java
@Value("${app.timeout}")
private int timeout;
```

⚠️ 缺点

* 多了会很乱
* 不适合复杂结构

 **生产环境：能用 `@ConfigurationProperties` 就别用 `@Value`**

---

## 八、运维 / 接口方向的经验总结

✔ Nacos 配置适合放：

* 开关
* 超时
* 地址
* 限流参数
* 功能灰度

❌ 不适合放：

* 密码明文（要配合加密）
* 强依赖启动顺序的参数

---

## 九、你接下来可以练的 3 个进阶点

1️ 多环境配置

```
demo-api-dev.yaml
demo-api-prod.yaml
```

2️ Namespace + Group 隔离

* 测试 / 生产完全隔离

3️ Nacos + Spring Boot 日志级别动态控制

> 改日志级别，不重启服务

---

如果你愿意，我可以直接给你一个：

* **完整 Maven 项目**
* **一键可跑**
* **带接口 + 日志 + Nacos**

你只要告诉我：
 **偏运维配置多一点，还是偏接口业务多一点？**
